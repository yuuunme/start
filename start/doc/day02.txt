# day02

java를 이용해 뭔가를 만들고 싶다면 컴파일러가 필요하고
	연계편집을 위한 도구가 필요하다.
	이것을 JVM 이라고 부른다.
	이 두가지를 제공하는 도구를 다운 받아서 사용해야 하는데
	그것이 바로 JDK이다.
	(두가지 기능 말고도 필요한 각종 도구들이 패키지로 묶여서
	제공되고 있다.)
	
------------------------------------------------------------------------
	사람이 인식할 수 있는 언어 - 자연어
	기계가 인식할 수 있는 언어 - 기계어, 어셈블리, C언어, 자바
							수준--------------------------------->
								C언어 : 자연어와 걸쳐져 있음.
								자바  : 자연어와 겹침.
------------------------------------------------------------------------
java로 만든 프로그램을 실행하는 원리

	1. 자바 언어의 문법에 맞게 자연어로 프로그램을 만든다.
		이 프로그램은 저장되어야 한다.
		프로그램 저장 규칙
			1) 저장할 파일의 이름은 Class 이름과 반드리 대소문자까지 동일해야 함
			2) 확장자는 반드시 .java로 만들어야 한다.
				ex) 
				class Test {
					. . .
				}
				====> Test.java : 파일이름
			3) class 반드시 만들고 프로그램 생성해야 함.
				.class 파일은 기계어가 아님 이걸 기계어로 바꿔주는
				역할을 하는 것이 JVM

	2. 만들어진 소스 파일은 컴파일을 해야 한다.
		그래야 컴퓨터가 이해할 수 있는 기계어가 탄생되기 때문이다.
		
		컴파일 하는 방법(형식)
		
			javac 파일이름.java
			
			ex) javac Test.java
				
			이때 옵션을 붙일 수도 있다.
				
			컴파일 단계를 거치면 확장자가 .class인 파일이 생성되는데
			이 파일을 바이트 코드라고 한다.
				=> Test.class
			ps. cmd 창에서는 현재 폴더에 있는 도구만 사용할 수 있는 것이 원칙
				다른 폴더에 있는 도구를 사용하기 위해서는 연결을 시켜줘야 한다.
				(해당 도구의 위치를 시스템이 인식하고 있으면 된다.)
				그 경로를 "Path"에 등록 해주면 된다.(환경 변수 작업)
				경로를 직접 입력해도 되지만(..어디에..?)
				환경 변수 작업을 해두면 자바가 업데이트가 되어도 경로가 자동으로
				변경되어 설정된다.
				
	3. 만들어진 class 파일은 배포가 된다.
		=>다른 사람에게 실행하도록 줄 수 있음.
		실행하는 방법
			java 클래스이름(확장자 생략 javac 에만 확장자 붙임.)
	
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
용어 설명 (중요도 낮음)
	*API 
	=> 운영체제와 프로그램 사이에 원활한 작동을 위해서 양쪽을 연결해주는 도구
	
	*라이브러리
	=> API가 사용하는 도구에 필요한 정보를 기억한 프로그램의 일종
	
		우리가 JDK를 설치하면
		자바로 만든 프로그램과 해당 운영체제 사이를 원활하게 작동시키기 위한
		API도 같이 설치가 된다. 
		
		이때 라이브러리도 같이 설치되는데
		특정 명령을 수행하기 위해서는 어떤 절차를 거쳐야 하는지를 기록한 문서에 해당
		
		ex)
			if(){
			}
			==> 이 명령을 실행하기 위해서는 절차가 필요.
				절차를 기록해 놓은 문서를 라이브러리라고 표현함.
				
		결론적으로 API 안에는 라이브러리가 반드시 포함되어야 한다.

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

소스 코드의 실행에는 영향을 미치지 않고
주로 설명을 하는데 사용하는 문장을 주석이라고 표현한다.
따라서 주석은 컴파일 되지 않는다.

자바에서 주석을 표현하는 방법
	1. 단일행(한줄 주석)
		형식 
			// 주석 내용
	2. 다중행(여러 줄) 주석
		형식
			/* 주석 내용 
					주석 내용 */
	3. 배포 문서에 포함되는 주석
		=> 이 클래스가 왜 만들어졌는지 공식적으로 설명하는 주석
			/** 주석 내용
			클래스 설명
			@author 만든이
			@since 만든 날짜 작성
			@version 만들 때 자바 버전
			@ 설명은 자유,,
			 */
			 
 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
 
 	함수는 함수 자신이 스스로 실행되는 경우는 없다.
 	함수는 반드시 누군가 호출해야 실행이 된다.
 	
 	함수를 호출하는 형식
 		
 			함수이름([데이터]);
 	
 	클래스가 실행되기 위해서는 JVM에 의해서 실행되는 함수가 있어야 한다.
 	
 	문제는 JVM은 아무 함수나 사용하는 것이 아니고
 	오직
 		"public static void main(String[] args)"
	이 함수만 호줄을 할 수 있다. * args 는 임의의 이름이고 아무 이름이나 사용 가능
	
	=> 이처럼 어떤 프로그램이 시작하는 함수를 진입점 함수라고 이야기 한다. 
	
	ex) public class Test04 {
			System.out.println("test");
		클래스 블럭(public class Test04)의 중괄호({) 뒤에 일반 명령을 내리면 오류가 남.
		
			클래스 안에는 필요한 함수나 필요한 변수를 포함할 수 있다. (클래스에 포함되는 함수, 변수 = '멤버'라고 부름)
			(클래스 : 하드디스크 파일 => Heap 영역에 저장됨)
			
			멤버로 만들어진 변수를 필드(Fields) 라고 부른다.
			멤버 중 속성이 static인 멤버는 static 멤버라 부른다.
			(static 멤버 : Heap 영역이 아닌 Static 영역에 저장됨)
			
			
			static 멤버의 특징
			1. static 영역에 실행되는 순간 미리 메모리에 올려지는 멤버들이다.
			2. 해당 멤버가 소속된 클래스를 new 시켜서 메모리에 올려놓지 않아도
				그 멤버는 사용할 수 있다.
			3. static 영역에 올려지는 멤버는 같은 이름으로 여러개 올려질 수 없다.
				=> 같은 이름으로 여러개 올리면 변수의 경우 하나를 공유해서 사용하게 되는 결과가 생긴다.
			4. static 함수에서는 static 멤버만(메모리에 기억되어 있는 멤버만) 사용할 수 있다.
				(static 함수는 메모리에 올려지지 않은(new라는 명령어 로 올려지지 않은) 멤버는 사용할 수 없다.) 
				
			
			필드 안의 함수들을 메소드 서머리(index에서 확인 가능)
			
			
			*클래스 안에 일반 명령은 절대로 올 수 없다.
				
					public class Test {
						int num;
						float area;		//변수도 포함할 수 있음.		
						
						public void xyz(){
						}
						
						public void abc(){
						}				//함수도 포함할 수 있다.
						
						public static void main(String[] args{
							실행내용(일반명령 등)
						}
		
		public static void main(String[] args)
			System.out.println("test");
		스태틱 보이드 함수에 사용하면 프로그램(System.out.println("test");)이 실행 가능
		 
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

	클래스 안에는 필요한 함수나 필요한 변수를 포함할 수 있다.
	(클래스 안에 일반 명령은 절대로 올 수 없다.)
	
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	
	*********중요********
	
	상수와 변수
	
		1. 상수(리터럴)
			개발자가 프로그램에게 알려주는 데이터(정보)
			
			ex]
			
				System.out.println("Hello");	// Hello라는 데이터 자체는 변경되지 않음
					"Hello"는 상수(Literal)이다.
					
				문제는 상수는 "Literal Pool" 이라는 장소에 저장하여 사용할 수 있는데
				같은 값이 중복되어 저장되지 않음. 같은 값이 중복되어 저장되면 먼저 저장된 것만 인정됨.
				
			ex]
			
				System.out.println("Hello"); 라고 명령을 하면
					 1) 먼저 리터럴 풀에 "Hello" 라는 데이터 자체를 기억시켜 놓고
					 		<== 이때 리터럴 풀은 메모리 영역이고
					 			기억되는 데이터는 입력되는 순간 주소를 가지게 된다.
		 			 2) 리터럴 풀에 기억된 데이터를 꺼내서 출력하게 된다.
		 			 
					 			
			상수의 종류 ]
			
				1). 정수형
						일반적인 소수점이 없는 숫자
							10		- 10진수
							010 	- 8진수
							0x10	- 16진수
				2). 실수형
						소수점이 존재하는 숫자
							3.14	- 일반적인 소수 방식
							3.0e5	= 지수 방식
									  3.0 * 10의 5승
				3). 논리형
					참과 거짓을 의미하는 데이터
						true
						false
						*C언어에서는 true와 false가 0와 1로 표현되지만 자바에서는 참과 거짓임.
						*자바의 경우 위의 2가지 이외에는 절대로 논리형을 표현할 수 없다.
						*자바에서 논리형 데이터에 값을 넣고 싶다면
							boolean bool = true;
								등의 명령을 해야 가능
								 
				4). 문자형 - '데이터' (작은 따옴포로 입력)				
					오직 한글자로만 구성된 문자를 의미(문자열을 기억하지 않고 문자 한글자씩만 기억)
						*내부적으로는 입력한 문자를 uni code 방식으로 변환해서 기억하게 된다.
						
						 문자형 기억 방식에는 두가지가 있다.
						
							'a' = 97 이라는 정수를 사용해서 기억한다.
							이때 사용되는 97이라는 숫자는 ascii 코드값이다.
							
							'\u0000' = 실제 유니코드 값으로 문자를 기억할 수 있다.
										0000은 원하는 문자에 해당하는 uni code 값
										
				5). 문자열형 - "데이터" (큰 따옴표로 입력)
					한글자 이상으로 구성된 문자를 의미한다.
						*기본 상수는 아니지만 개발자 입장에서 매우 빈번하게 사용하는 형태

		2. 변수
			*변수의 필요성
			 개발자가 입력한 데이터는 일단 리터럴 풀에 저장된다.
			 그리고 프로그램이 리터럴 풀에 있는 데이터를 꺼내서 사용하게 된다.
			 
			 리터럴 풀은 메모리 영역 중 하나고 주소를 모르면 사용할 수 없다.
			 (반드시 주소를 알아야 사용 가능)
			 
			 변수는 리터럴 풀에 저장된 데이터를 개발자가 필요한 순간에 다시 재사용할 수 있도록
			 저장된 주소를 기억해 놓는 역할을 한다.
			 
			 *Stack의 특징
			 	1. 메모리에 별칭을 붙여서 사용할 수 있는 역역이다.
			 		(별칭은 개발자가 붙이는 것이므로 개발자가 가장 손쉽게 사용할 수 있는 영역이다.)
			 	2. 8개의 저장 영역 중에서 리터럴 풀 다음으로 가장 작은 영역을 운영체제에서 배정 받는다.
			 		(Stack에는 많은 양의 데이터를 보관하면 문제가 생길 수 있다.)
		 		
		 		
		 		-----------------
		 		
		 		리터럴 풀에 있는 데이터를 Stack에서 기억하는 방법
		 		
		 			1. Stack에 필요한 메모리를 할당 받는다.
		 			
		 				형식 ]
		 					데이터 타입		변수이름;
		 					
	 					*데이터 타입의 기술은 2가지 의미를 담고 있다.
	 						1) 기억할 데이터의 형태
	 						2) 필요한 메모리의 크기
		 					
	 					* 변수 이름은 앞에서 설명한 Stack에 붙이는 별칭이다.
	 					따라서 변수 이름만 기억하고 있으면 언제든지
	 					이 변수가 기억하고 있는 데이터를 사용할 수 있게 된다.
	 					
						* Stack 영역에 메모리를 할당받는 방법
 						JVM에게 할당 받은 메모리 크기와 그 안에 저장할 데이터 형태를 알려줘야 한다.
	 					
	 					*데이터 타입에 의한 변수의 분류
	 						1) 기본형 변수
	 							- 자바에서 제공해 주는 기본 데이터 타입의 데이터를 기억하는 변수
 								 			
	 								자바의 기본 데이터 타입
	 									논리형 		-1byte
	 										boolean
 										문자형 		- 2byte
 											char
										정수형 
											byte  	-1byte
											short 	-2byte
											int 	-4byte
											long	-8byte
										실수형	
											float	-4byte
											double	-8byte
	 							
 							2) 잠조형 변수
 								- 기본형 데이터 이외의 모든 데이터를 기억하는 변수(class를 기억)
	 					
 					2. 대입(기억) 연산자를 이용해서 필요한 데이터를 기억한다.
 					
 						형식 ]
 							변수이름 = 데이터;	//옆 명령을 하는 순간 데이터는 리터럴 풀에 저장됨.
 						ex   ] no = 10;
 						
 	
=========================================
	자바 프로그램의 토큰 구분
	- 컴파일러는 토큰단위로 번역을 시도한다.
		따라서 개발자는 컴파일러가 번역하는 토큰을 구분해 줘야 한다.
		이것이 " ; " 이라는 기호를 이용해서 구분하게 된다.
		
		우리가 습관적으로
			int no = 10;
		을 했던 의미는 토큰을 구분하기 위한 기호였다.
		
		결과적으로 토큰은 하나의 명령이 종료되었음을 알려주는 기호가 된다. (하나의 명령을 실행하고 끝냄)
		만약 개발자가 토큰 구분을 하지 않으면 오류가 발생할 수 있다.
		
			ex ]	명령 끝에 토큰(;)을 붙이지 않으면 명령이 명령 여러개 중 구분을 못하기 때문에 오류 발생
				int no1 = 10
				int no2 = 20;
				==> 컴파일러는 두줄을 하나의 명령으로 인식해서
					처리하게 될 것이고
					이런 명령 형식은 존재하지 않으므로 에러가 발생한다.
		 
		 ex ] 
		 	int no1 = 10; int no2 = 10;
		 	==> 한 줄에 쓰더라도 토큰으로 명령 구분을 했기 때문에 오류가 나지 않음.
		 		한 줄로 입력했지만 no1을 먼저 처리하고 그 명령이 처리된 후
		 		no2에 대한 명령을 처리하게 된다.
		 		
 		참고 ]
 			토큰 기호 세미콜론 ';' 대신 '}' 기호가 그 역할을 대신할 수 있다.
 			
 			ex ]
 				if(조건식){
 					실행문...
 				}
				==> 조건식이 맞으면 실행문을 실행하는 if문인데, 이 때는 토큰기호 ';' 대신 끝의 '}'에서
					토큰이 발생하게 된다. 