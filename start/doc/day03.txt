# day03

컴퓨터가 숫자를 기억하는 방법

	
		1. 정수의 경우 
			=> 2진수로 변환
			   부호 비트는 무조건 0을 붙인다

	
		2. 음수의 경우
			=> 9의 보수법을 이용해서 처리한다.
				
				1) 양수로 가정하고 2진수로 변환한다
				2) 보수화 시킨다. (현재 숫자를 바꾼다. 0 -> 1, 1 -> 0 ====> 비트를 뒤집는다.)
				3) 뒤집은 비트에 + 1 해 준다.
				4) 부호 비트에 강제로 1을 지정한다.

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ				
연산자
	데이터를 가공하기 위해 사용되는 기호
	
		연산자	-가공 방식을 나타내는 기호
		피연산자-가공에 사용되는 데이터
		
		예 ]
		
			1+2 ==> + : 연산자, 1과 2는 피연산자(연산 당하는)
			
		참고]
			
			연산자를 사용하면 가공된 결과가 나오는데
			이 결과는 항상 큰 형태로 나오는 것을 원칙으로 한다.
			
			예 ]
				
				1+ 3.14 => 4.14 이때 결과값의 데이터 형태는 double
				int + double ==> double
				
				day03 Test02 참고						* 연습 문제
														'J' + 3.14 ===>
																		
														대문자 A = 아스키 코드값이 '65'
														J는 (알파벳순으로 A부터 알파벳순으로 10번째) 
														74로 변환이 되서 연산을 하게 된다.
														따라서 74 + 3.14 의 연산을 하게 되고
														결과값은 double형 데이터 77.14 가 된다.
				
				char + int => int
				float+long =>float		
				
				**두개의 다른 데이터 값을 합할 때 데이터의 값(바이트)가 더 큰 형태로 나옴.
				=======> *****이게 바로 자동 형변환 ******
				
				참고 ]
				
					기본 데이터 타입 + 문자열 데이터 ==> 문자열 데이터
					
						예 ]
						
							3.14 + "!!!" ==> 3.14!!!
							이때 + 는 산술 연산을 하는 것이 아니고
							데이터 2개를 결합하는 결합 연산자로서 작동된다.
							
							**모든 데이터 타입에 문자열을 더하면 문자열 데이터가 됨!!
							
							
			
			
			주의 ]
			
				수학에서는 비교 연산을 할 때
				3개의 항을 동시에 비교할 수 있었지만
				프로그래밍에서는 절대로 3개 이상의 피연산자를 동시에 연산할 수 없다.
				
				1 < x < 10       ==> 수학적 방식
				
				x > 1; x < 10;
					or			 ==> 프로그래밍(자바)의 방식
				x > 1 and x < 10
				
				
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ				
	<연산자의 종류>
	
		1. 사칙연산자
						=> 더하고 빼고 곱하고 나누고 나머지 구하는 연산자
		 	연산자	기호	+		-	*		/		%
					
					Test04 참고, 사칙연산자는 피연산자가 반드시 2개가 필요하다.
								 사칙연산자가 여러개 동시에 기술된 경우에는
								 왼쪽부터 차례로 계산해서 결과값을 만들어 나간다.
		
		2. 대입연산자 (**비교연산자와 헷갈릴 수 있음)
					=> 변수에 데이터를 기억하도록 하는 연산자
					기호 	 = (이콜)
							+=
							-=
							*=
							/=
							%=
						
					형식 ]	
						변수 = 데이터;			//데이터를 변수에 기억 시키세요 라는 뜻
						*반드시 대입연산자 왼쪽에는 변수가
										   오른쪽에는 데이터가 위치해야 한다.
					   *자바는 모든 연산이 반드시 대입연산자가 있어야 기억할 수 있다.
					   만약 대입하지 않으면 연산의 결과는 기억되지 못한다.
					   
					   참고 ]
					   	모든 연산자는 같은 연산자가 중복된 경우 왼쪽에서 오른쪽으로 진행하면서 한다
					   	
					   	예 ]
					   		1 + 2 + 3 + 4 + 5
					   			1 + 2
					   				  + 3
					   				 	 + 4
											 + 5
							이런 순서로 연산을 진행하는데
							대입 연산자 만큼은 오른쪽에서 왼쪽으로 진행한다.
							
							예 ]
								int a = 10;
								int b = 20;
								int c = 30;
								int b = 40;
								
								a = b = c = d;
								<---------------- 오른쪽에서 왼쪽 방향으로 대입연산이 이루어진다.
								a = b = c = d;의 값은 40이 됨				 
								
								참고 ]
								
								변수 = 변수 + 데이터;
								==> 이렇게 쓸 수도 있음
								
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
*참고
	 ' + ' 플러스 기호는 문자열 연산에서도 사용할 수 있다.
	 (문자열 연산은 오직 + 기호만 사용할 수 있다.)
	 => 이 때 문자열이 결합되어서 결과가 만들어지게 된다.
	 	결합이란 ?
	 		앞 문자열 뒤 문자열이 붙어서 만들어지ㅡㄴ 것
	 		
	 		"홍" + "길동"	= "홍길동"
	 				
	 				*모든 데이터 타입의 데이터를 문자열에 결합하면
	 				문자열 데이터가 만들어진다.
	 				
	 				*문자열 결합은 문자열이 단 한개만 있어도 허용된다.
	 				즉 결합하는 두 항 중 하나만 문자열이라도 문자열 결합으로 처리된다. (문자열 데이터가 더 크니까)
	 																					= 자동형변환? 이라는 뜻인가?
	 																					
	 		"홍" + 1000 = "홍1000"
	 		200 + "홍" = "200홍"
	 		
*참고	 System.out.println(데이터) 에서는 오직 한개만 출력할 수 있다.
	 	 예 ]
	 	 	System.out.println("홍길동","고길동","둘리");  <==오류남. 
	 	 			
	 	 			콤마(,)로 여러개의 데이터를 집어넣을 수 없다.
	 	 			여러개의 데이터를 출력하고자 하면
	 	 			문자열 결합 (+ 연산자 사용)을 이용해서 결합해 하나의 문자열을 만든 후 출력해야 한다. 
	 		
	 		
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ		
		
		3. 증감연산자 Test05참고
		
			형식 ] 
				++변수	=> 연산자 기준으로 바로 다음에 오는 변수를 1 증가시켜 달라.
				
				변수++
				
				!!!!!!!!!!Test05 참고
		
			기호 ]
				++ : 1 증가시켜 준다.
				__ : 1 감소시켜 준다.
				
			참고 ]
				모든 연산은 일반적으로 중앙처리장치에서 처리되는 것이 원칙이다.
				증감연산가, 시프트 연산자는 중앙처리장치를 거치지 않는다
				메모리 상에서 연산되서 처리된다.
		
		4. 부호반전연산자
			
			형식 ]
				-데이터;
			
			기호 ]
				-
		5. 비교연산자
			=> 두 데이터의 대소 관계를 비교하는 연산자
			
			기호 ]
				== 같다
				!= 같지 않다 (! => 부정하는 연산자)
				> 크다
				< 작다
				>= 크거나 작다. ( =(이콜) 다음에 >, < 가 오는 경우는 없음)
				<= 작거나 같다.
			
			주의 ]
				사용되는 데이터와 관계없이 결과는 항상 논리값(true, false)으로 나온다.
				
			참고 ]
				이 연산자는 주로  if, for, while, ... 등의 제어 명령에서 질문이 필요할 때 많이 쓰임
				* 문자열을 비교할 경우에는 equals()를 사용해서 비교해야
				정확하게 데이터를 비교할 수 있다. (동승연산자만 사용해서 비교할 경우 주소의 값만 비교하기 때문에
													원하는 결과가 나오지 않을 수 있다.)
													
				비교 연산자는 3항을 동시에 비교하지 못한다.
					예 ]
						10 <= no < 100 ===========> 불가능
						no >= 10 and no < 100 ====>   가능
													
		6. 논리연산자
				기호 ]
						
					
				
		7. 비트연산자
		
		8. 3항연산자(조건연산자)
		
		
		
		